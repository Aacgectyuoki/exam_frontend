{"ast":null,"code":"/**\r\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\r\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\r\n */\nimport Watchdog from './watchdog';\nimport EditorWatchdog from './editorwatchdog';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties';\nimport getSubNodes from './utils/getsubnodes';\nconst mainQueueId = Symbol('MainQueueId');\n/**\r\n * A watchdog for the {@link module:core/context~Context} class.\r\n *\r\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\r\n * how to use it.\r\n */\n\nexport default class ContextWatchdog extends Watchdog {\n  /**\r\n   * The context watchdog class constructor.\r\n   *\r\n   * ```ts\r\n   * const watchdog = new ContextWatchdog( Context );\r\n   *\r\n   * await watchdog.create( contextConfiguration );\r\n   *\r\n   * await watchdog.add( item );\r\n   * ```\r\n   *\r\n   * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\r\n   *\r\n   * @param Context The {@link module:core/context~Context} class.\r\n   * @param watchdogConfig The watchdog configuration.\r\n   */\n  constructor(Context, watchdogConfig = {}) {\n    super(watchdogConfig);\n    /**\r\n     * A map of internal watchdogs for added items.\r\n     */\n\n    this._watchdogs = new Map();\n    /**\r\n     * The current context instance.\r\n     */\n\n    this._context = null;\n    /**\r\n     * Context properties (nodes/references) that are gathered during the initial context creation\r\n     * and are used to distinguish the origin of an error.\r\n     */\n\n    this._contextProps = new Set();\n    /**\r\n     * An action queue, which is used to handle async functions queuing.\r\n     */\n\n    this._actionQueues = new ActionQueues();\n    this._watchdogConfig = watchdogConfig; // Default creator and destructor.\n\n    this._creator = contextConfig => Context.create(contextConfig);\n\n    this._destructor = context => context.destroy();\n\n    this._actionQueues.onEmpty(() => {\n      if (this.state === 'initializing') {\n        this.state = 'ready';\n\n        this._fire('stateChange');\n      }\n    });\n  }\n  /**\r\n   * Sets the function that is responsible for the context creation.\r\n   * It expects a function that should return a promise (or `undefined`).\r\n   *\r\n   * ```ts\r\n   * watchdog.setCreator( config => Context.create( config ) );\r\n   * ```\r\n   */\n\n\n  setCreator(creator) {\n    this._creator = creator;\n  }\n  /**\r\n   * Sets the function that is responsible for the context destruction.\r\n   * Overrides the default destruction function, which destroys only the context instance.\r\n   * It expects a function that should return a promise (or `undefined`).\r\n   *\r\n   * ```ts\r\n   * watchdog.setDestructor( context => {\r\n   * \t// Do something before the context is destroyed.\r\n   *\r\n   * \treturn context\r\n   * \t\t.destroy()\r\n   * \t\t.then( () => {\r\n   * \t\t\t// Do something after the context is destroyed.\r\n   * \t\t} );\r\n   * } );\r\n   * ```\r\n   */\n\n\n  setDestructor(destructor) {\n    this._destructor = destructor;\n  }\n  /**\r\n   * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\r\n   * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\r\n   */\n\n\n  get context() {\n    return this._context;\n  }\n  /**\r\n   * Initializes the context watchdog. Once it is created, the watchdog takes care about\r\n   * recreating the context and the provided items, and starts the error handling mechanism.\r\n   *\r\n   * ```ts\r\n   * await watchdog.create( {\r\n   * \tplugins: []\r\n   * } );\r\n   * ```\r\n   *\r\n   * @param contextConfig The context configuration. See {@link module:core/context~Context}.\r\n   */\n\n\n  create(contextConfig = {}) {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this._contextConfig = contextConfig;\n      return this._create();\n    });\n  }\n  /**\r\n   * Returns an item instance with the given `itemId`.\r\n   *\r\n   * ```ts\r\n   * const editor1 = watchdog.getItem( 'editor1' );\r\n   * ```\r\n   *\r\n   * @param itemId The item ID.\r\n   * @returns The item instance or `undefined` if an item with a given ID has not been found.\r\n   */\n\n\n  getItem(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n\n    return watchdog._item;\n  }\n  /**\r\n   * Gets the state of the given item. See {@link #state} for a list of available states.\r\n   *\r\n   * ```ts\r\n   * const editor1State = watchdog.getItemState( 'editor1' );\r\n   * ```\r\n   *\r\n   * @param itemId Item ID.\r\n   * @returns The state of the item.\r\n   */\n\n\n  getItemState(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n\n    return watchdog.state;\n  }\n  /**\r\n   * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\r\n   *\r\n   * Items can be passed together as an array of objects:\r\n   *\r\n   * ```ts\r\n   * await watchdog.add( [ {\r\n   * \tid: 'editor1',\r\n   * \ttype: 'editor',\r\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\r\n   * \tconfig: {\r\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\r\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\r\n   * \t},\r\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\r\n   * } ] );\r\n   * ```\r\n   *\r\n   * Or one by one as objects:\r\n   *\r\n   * ```ts\r\n   * await watchdog.add( {\r\n   * \tid: 'editor1',\r\n   * \ttype: 'editor',\r\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\r\n   * \tconfig: {\r\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\r\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\r\n   * \t},\r\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\r\n   * ] );\r\n   * ```\r\n   *\r\n   * Then an instance can be retrieved using the {@link #getItem} method:\r\n   *\r\n   * ```ts\r\n   * const editor1 = watchdog.getItem( 'editor1' );\r\n   * ```\r\n   *\r\n   * Note that this method can be called multiple times, but for performance reasons it is better\r\n   * to pass all items together.\r\n   *\r\n   * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\r\n   */\n\n\n  add(itemConfigurationOrItemConfigurations) {\n    const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n    return Promise.all(itemConfigurations.map(item => {\n      return this._actionQueues.enqueue(item.id, () => {\n        if (this.state === 'destroyed') {\n          throw new Error('Cannot add items to destroyed watchdog.');\n        }\n\n        if (!this._context) {\n          throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n        }\n\n        let watchdog;\n\n        if (this._watchdogs.has(item.id)) {\n          throw new Error(`Item with the given id is already added: '${item.id}'.`);\n        }\n\n        if (item.type === 'editor') {\n          watchdog = new EditorWatchdog(null, this._watchdogConfig);\n          watchdog.setCreator(item.creator);\n\n          watchdog._setExcludedProperties(this._contextProps);\n\n          if (item.destructor) {\n            watchdog.setDestructor(item.destructor);\n          }\n\n          this._watchdogs.set(item.id, watchdog); // Enqueue the internal watchdog errors within the main queue.\n          // And propagate the internal `error` events as `itemError` event.\n\n\n          watchdog.on('error', (evt, {\n            error,\n            causesRestart\n          }) => {\n            this._fire('itemError', {\n              itemId: item.id,\n              error\n            }); // Do not enqueue the item restart action if the item will not restart.\n\n\n            if (!causesRestart) {\n              return;\n            }\n\n            this._actionQueues.enqueue(item.id, () => new Promise(res => {\n              const rethrowRestartEventOnce = () => {\n                watchdog.off('restart', rethrowRestartEventOnce);\n\n                this._fire('itemRestart', {\n                  itemId: item.id\n                });\n\n                res();\n              };\n\n              watchdog.on('restart', rethrowRestartEventOnce);\n            }));\n          });\n          return watchdog.create(item.sourceElementOrData, item.config, this._context);\n        } else {\n          throw new Error(`Not supported item type: '${item.type}'.`);\n        }\n      });\n    }));\n  }\n  /**\r\n   * Removes and destroys item(s) with given ID(s).\r\n   *\r\n   * ```ts\r\n   * await watchdog.remove( 'editor1' );\r\n   * ```\r\n   *\r\n   * Or\r\n   *\r\n   * ```ts\r\n   * await watchdog.remove( [ 'editor1', 'editor2' ] );\r\n   * ```\r\n   *\r\n   * @param itemIdOrItemIds Item ID or an array of item IDs.\r\n   */\n\n\n  remove(itemIdOrItemIds) {\n    const itemIds = toArray(itemIdOrItemIds);\n    return Promise.all(itemIds.map(itemId => {\n      return this._actionQueues.enqueue(itemId, () => {\n        const watchdog = this._getWatchdog(itemId);\n\n        this._watchdogs.delete(itemId);\n\n        return watchdog.destroy();\n      });\n    }));\n  }\n  /**\r\n   * Destroys the context watchdog and all added items.\r\n   * Once the context watchdog is destroyed, new items cannot be added.\r\n   *\r\n   * ```ts\r\n   * await watchdog.destroy();\r\n   * ```\r\n   */\n\n\n  destroy() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'destroyed';\n\n      this._fire('stateChange');\n\n      super.destroy();\n      return this._destroy();\n    });\n  }\n  /**\r\n   * Restarts the context watchdog.\r\n   */\n\n\n  _restart() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'initializing';\n\n      this._fire('stateChange');\n\n      return this._destroy().catch(err => {\n        console.error('An error happened during destroying the context or items.', err);\n      }).then(() => this._create()).then(() => this._fire('restart'));\n    });\n  }\n  /**\r\n   * Initializes the context watchdog.\r\n   */\n\n\n  _create() {\n    return Promise.resolve().then(() => {\n      this._startErrorHandling();\n\n      return this._creator(this._contextConfig);\n    }).then(context => {\n      this._context = context;\n      this._contextProps = getSubNodes(this._context);\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => {\n        watchdog._setExcludedProperties(this._contextProps);\n\n        return watchdog.create(undefined, undefined, this._context);\n      }));\n    });\n  }\n  /**\r\n   * Destroys the context instance and all added items.\r\n   */\n\n\n  _destroy() {\n    return Promise.resolve().then(() => {\n      this._stopErrorHandling();\n\n      const context = this._context;\n      this._context = null;\n      this._contextProps = new Set();\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => watchdog.destroy())) // Context destructor destroys each editor.\n      .then(() => this._destructor(context));\n    });\n  }\n  /**\r\n   * Returns the watchdog for a given item ID.\r\n   *\r\n   * @param itemId Item ID.\r\n   */\n\n\n  _getWatchdog(itemId) {\n    const watchdog = this._watchdogs.get(itemId);\n\n    if (!watchdog) {\n      throw new Error(`Item with the given id was not registered: ${itemId}.`);\n    }\n\n    return watchdog;\n  }\n  /**\r\n   * Checks whether an error comes from the context instance and not from the item instances.\r\n   *\r\n   * @internal\r\n   */\n\n\n  _isErrorComingFromThisItem(error) {\n    for (const watchdog of this._watchdogs.values()) {\n      if (watchdog._isErrorComingFromThisItem(error)) {\n        return false;\n      }\n    }\n\n    return areConnectedThroughProperties(this._context, error.context);\n  }\n\n}\n/**\r\n * Manager of action queues that allows queuing async functions.\r\n */\n\nclass ActionQueues {\n  constructor() {\n    this._onEmptyCallbacks = [];\n    this._queues = new Map();\n    this._activeActions = 0;\n  }\n  /**\r\n   * Used to register callbacks that will be run when the queue becomes empty.\r\n   *\r\n   * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\r\n   */\n\n\n  onEmpty(onEmptyCallback) {\n    this._onEmptyCallbacks.push(onEmptyCallback);\n  }\n  /**\r\n   * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\r\n   *\r\n   * @param queueId The action queue ID.\r\n   * @param action A function that should be enqueued.\r\n   */\n\n\n  enqueue(queueId, action) {\n    const isMainAction = queueId === mainQueueId;\n    this._activeActions++;\n\n    if (!this._queues.get(queueId)) {\n      this._queues.set(queueId, Promise.resolve());\n    } // List all sources of actions that the current action needs to await for.\n    // For the main action wait for all other actions.\n    // For the item action wait only for the item queue and the main queue.\n\n\n    const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n    const queueWithAction = awaitedActions.then(action); // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n\n    const nonErrorQueue = queueWithAction.catch(() => {});\n\n    this._queues.set(queueId, nonErrorQueue);\n\n    return queueWithAction.finally(() => {\n      this._activeActions--;\n\n      if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n        this._onEmptyCallbacks.forEach(cb => cb());\n      }\n    });\n  }\n\n}\n/**\r\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\r\n *\r\n * @param elementOrArray The value to transform to an array.\r\n * @returns An array created from data.\r\n */\n\n\nfunction toArray(elementOrArray) {\n  return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}","map":{"version":3,"sources":["D:/UpWork/Max Dell-Thibodeau/exam_frontend/node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js"],"names":["Watchdog","EditorWatchdog","areConnectedThroughProperties","getSubNodes","mainQueueId","Symbol","ContextWatchdog","constructor","Context","watchdogConfig","_watchdogs","Map","_context","_contextProps","Set","_actionQueues","ActionQueues","_watchdogConfig","_creator","contextConfig","create","_destructor","context","destroy","onEmpty","state","_fire","setCreator","creator","setDestructor","destructor","enqueue","_contextConfig","_create","getItem","itemId","watchdog","_getWatchdog","_item","getItemState","add","itemConfigurationOrItemConfigurations","itemConfigurations","toArray","Promise","all","map","item","id","Error","has","type","_setExcludedProperties","set","on","evt","error","causesRestart","res","rethrowRestartEventOnce","off","sourceElementOrData","config","remove","itemIdOrItemIds","itemIds","delete","_destroy","_restart","catch","err","console","then","resolve","_startErrorHandling","Array","from","values","undefined","_stopErrorHandling","get","_isErrorComingFromThisItem","_onEmptyCallbacks","_queues","_activeActions","onEmptyCallback","push","queueId","action","isMainAction","awaitedActions","queueWithAction","nonErrorQueue","finally","forEach","cb","elementOrArray","isArray"],"mappings":"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","sourcesContent":["/**\r\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\r\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\r\n */\r\nimport Watchdog from './watchdog';\r\nimport EditorWatchdog from './editorwatchdog';\r\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties';\r\nimport getSubNodes from './utils/getsubnodes';\r\nconst mainQueueId = Symbol('MainQueueId');\r\n/**\r\n * A watchdog for the {@link module:core/context~Context} class.\r\n *\r\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\r\n * how to use it.\r\n */\r\nexport default class ContextWatchdog extends Watchdog {\r\n    /**\r\n     * The context watchdog class constructor.\r\n     *\r\n     * ```ts\r\n     * const watchdog = new ContextWatchdog( Context );\r\n     *\r\n     * await watchdog.create( contextConfiguration );\r\n     *\r\n     * await watchdog.add( item );\r\n     * ```\r\n     *\r\n     * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\r\n     *\r\n     * @param Context The {@link module:core/context~Context} class.\r\n     * @param watchdogConfig The watchdog configuration.\r\n     */\r\n    constructor(Context, watchdogConfig = {}) {\r\n        super(watchdogConfig);\r\n        /**\r\n         * A map of internal watchdogs for added items.\r\n         */\r\n        this._watchdogs = new Map();\r\n        /**\r\n         * The current context instance.\r\n         */\r\n        this._context = null;\r\n        /**\r\n         * Context properties (nodes/references) that are gathered during the initial context creation\r\n         * and are used to distinguish the origin of an error.\r\n         */\r\n        this._contextProps = new Set();\r\n        /**\r\n         * An action queue, which is used to handle async functions queuing.\r\n         */\r\n        this._actionQueues = new ActionQueues();\r\n        this._watchdogConfig = watchdogConfig;\r\n        // Default creator and destructor.\r\n        this._creator = contextConfig => Context.create(contextConfig);\r\n        this._destructor = context => context.destroy();\r\n        this._actionQueues.onEmpty(() => {\r\n            if (this.state === 'initializing') {\r\n                this.state = 'ready';\r\n                this._fire('stateChange');\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Sets the function that is responsible for the context creation.\r\n     * It expects a function that should return a promise (or `undefined`).\r\n     *\r\n     * ```ts\r\n     * watchdog.setCreator( config => Context.create( config ) );\r\n     * ```\r\n     */\r\n    setCreator(creator) {\r\n        this._creator = creator;\r\n    }\r\n    /**\r\n     * Sets the function that is responsible for the context destruction.\r\n     * Overrides the default destruction function, which destroys only the context instance.\r\n     * It expects a function that should return a promise (or `undefined`).\r\n     *\r\n     * ```ts\r\n     * watchdog.setDestructor( context => {\r\n     * \t// Do something before the context is destroyed.\r\n     *\r\n     * \treturn context\r\n     * \t\t.destroy()\r\n     * \t\t.then( () => {\r\n     * \t\t\t// Do something after the context is destroyed.\r\n     * \t\t} );\r\n     * } );\r\n     * ```\r\n     */\r\n    setDestructor(destructor) {\r\n        this._destructor = destructor;\r\n    }\r\n    /**\r\n     * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\r\n     * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\r\n     */\r\n    get context() {\r\n        return this._context;\r\n    }\r\n    /**\r\n     * Initializes the context watchdog. Once it is created, the watchdog takes care about\r\n     * recreating the context and the provided items, and starts the error handling mechanism.\r\n     *\r\n     * ```ts\r\n     * await watchdog.create( {\r\n     * \tplugins: []\r\n     * } );\r\n     * ```\r\n     *\r\n     * @param contextConfig The context configuration. See {@link module:core/context~Context}.\r\n     */\r\n    create(contextConfig = {}) {\r\n        return this._actionQueues.enqueue(mainQueueId, () => {\r\n            this._contextConfig = contextConfig;\r\n            return this._create();\r\n        });\r\n    }\r\n    /**\r\n     * Returns an item instance with the given `itemId`.\r\n     *\r\n     * ```ts\r\n     * const editor1 = watchdog.getItem( 'editor1' );\r\n     * ```\r\n     *\r\n     * @param itemId The item ID.\r\n     * @returns The item instance or `undefined` if an item with a given ID has not been found.\r\n     */\r\n    getItem(itemId) {\r\n        const watchdog = this._getWatchdog(itemId);\r\n        return watchdog._item;\r\n    }\r\n    /**\r\n     * Gets the state of the given item. See {@link #state} for a list of available states.\r\n     *\r\n     * ```ts\r\n     * const editor1State = watchdog.getItemState( 'editor1' );\r\n     * ```\r\n     *\r\n     * @param itemId Item ID.\r\n     * @returns The state of the item.\r\n     */\r\n    getItemState(itemId) {\r\n        const watchdog = this._getWatchdog(itemId);\r\n        return watchdog.state;\r\n    }\r\n    /**\r\n     * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\r\n     *\r\n     * Items can be passed together as an array of objects:\r\n     *\r\n     * ```ts\r\n     * await watchdog.add( [ {\r\n     * \tid: 'editor1',\r\n     * \ttype: 'editor',\r\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\r\n     * \tconfig: {\r\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\r\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\r\n     * \t},\r\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\r\n     * } ] );\r\n     * ```\r\n     *\r\n     * Or one by one as objects:\r\n     *\r\n     * ```ts\r\n     * await watchdog.add( {\r\n     * \tid: 'editor1',\r\n     * \ttype: 'editor',\r\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\r\n     * \tconfig: {\r\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\r\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\r\n     * \t},\r\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\r\n     * ] );\r\n     * ```\r\n     *\r\n     * Then an instance can be retrieved using the {@link #getItem} method:\r\n     *\r\n     * ```ts\r\n     * const editor1 = watchdog.getItem( 'editor1' );\r\n     * ```\r\n     *\r\n     * Note that this method can be called multiple times, but for performance reasons it is better\r\n     * to pass all items together.\r\n     *\r\n     * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\r\n     */\r\n    add(itemConfigurationOrItemConfigurations) {\r\n        const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\r\n        return Promise.all(itemConfigurations.map(item => {\r\n            return this._actionQueues.enqueue(item.id, () => {\r\n                if (this.state === 'destroyed') {\r\n                    throw new Error('Cannot add items to destroyed watchdog.');\r\n                }\r\n                if (!this._context) {\r\n                    throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\r\n                }\r\n                let watchdog;\r\n                if (this._watchdogs.has(item.id)) {\r\n                    throw new Error(`Item with the given id is already added: '${item.id}'.`);\r\n                }\r\n                if (item.type === 'editor') {\r\n                    watchdog = new EditorWatchdog(null, this._watchdogConfig);\r\n                    watchdog.setCreator(item.creator);\r\n                    watchdog._setExcludedProperties(this._contextProps);\r\n                    if (item.destructor) {\r\n                        watchdog.setDestructor(item.destructor);\r\n                    }\r\n                    this._watchdogs.set(item.id, watchdog);\r\n                    // Enqueue the internal watchdog errors within the main queue.\r\n                    // And propagate the internal `error` events as `itemError` event.\r\n                    watchdog.on('error', (evt, { error, causesRestart }) => {\r\n                        this._fire('itemError', { itemId: item.id, error });\r\n                        // Do not enqueue the item restart action if the item will not restart.\r\n                        if (!causesRestart) {\r\n                            return;\r\n                        }\r\n                        this._actionQueues.enqueue(item.id, () => new Promise(res => {\r\n                            const rethrowRestartEventOnce = () => {\r\n                                watchdog.off('restart', rethrowRestartEventOnce);\r\n                                this._fire('itemRestart', { itemId: item.id });\r\n                                res();\r\n                            };\r\n                            watchdog.on('restart', rethrowRestartEventOnce);\r\n                        }));\r\n                    });\r\n                    return watchdog.create(item.sourceElementOrData, item.config, this._context);\r\n                }\r\n                else {\r\n                    throw new Error(`Not supported item type: '${item.type}'.`);\r\n                }\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * Removes and destroys item(s) with given ID(s).\r\n     *\r\n     * ```ts\r\n     * await watchdog.remove( 'editor1' );\r\n     * ```\r\n     *\r\n     * Or\r\n     *\r\n     * ```ts\r\n     * await watchdog.remove( [ 'editor1', 'editor2' ] );\r\n     * ```\r\n     *\r\n     * @param itemIdOrItemIds Item ID or an array of item IDs.\r\n     */\r\n    remove(itemIdOrItemIds) {\r\n        const itemIds = toArray(itemIdOrItemIds);\r\n        return Promise.all(itemIds.map(itemId => {\r\n            return this._actionQueues.enqueue(itemId, () => {\r\n                const watchdog = this._getWatchdog(itemId);\r\n                this._watchdogs.delete(itemId);\r\n                return watchdog.destroy();\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * Destroys the context watchdog and all added items.\r\n     * Once the context watchdog is destroyed, new items cannot be added.\r\n     *\r\n     * ```ts\r\n     * await watchdog.destroy();\r\n     * ```\r\n     */\r\n    destroy() {\r\n        return this._actionQueues.enqueue(mainQueueId, () => {\r\n            this.state = 'destroyed';\r\n            this._fire('stateChange');\r\n            super.destroy();\r\n            return this._destroy();\r\n        });\r\n    }\r\n    /**\r\n     * Restarts the context watchdog.\r\n     */\r\n    _restart() {\r\n        return this._actionQueues.enqueue(mainQueueId, () => {\r\n            this.state = 'initializing';\r\n            this._fire('stateChange');\r\n            return this._destroy()\r\n                .catch(err => {\r\n                console.error('An error happened during destroying the context or items.', err);\r\n            })\r\n                .then(() => this._create())\r\n                .then(() => this._fire('restart'));\r\n        });\r\n    }\r\n    /**\r\n     * Initializes the context watchdog.\r\n     */\r\n    _create() {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n            this._startErrorHandling();\r\n            return this._creator(this._contextConfig);\r\n        })\r\n            .then(context => {\r\n            this._context = context;\r\n            this._contextProps = getSubNodes(this._context);\r\n            return Promise.all(Array.from(this._watchdogs.values())\r\n                .map(watchdog => {\r\n                watchdog._setExcludedProperties(this._contextProps);\r\n                return watchdog.create(undefined, undefined, this._context);\r\n            }));\r\n        });\r\n    }\r\n    /**\r\n     * Destroys the context instance and all added items.\r\n     */\r\n    _destroy() {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n            this._stopErrorHandling();\r\n            const context = this._context;\r\n            this._context = null;\r\n            this._contextProps = new Set();\r\n            return Promise.all(Array.from(this._watchdogs.values())\r\n                .map(watchdog => watchdog.destroy()))\r\n                // Context destructor destroys each editor.\r\n                .then(() => this._destructor(context));\r\n        });\r\n    }\r\n    /**\r\n     * Returns the watchdog for a given item ID.\r\n     *\r\n     * @param itemId Item ID.\r\n     */\r\n    _getWatchdog(itemId) {\r\n        const watchdog = this._watchdogs.get(itemId);\r\n        if (!watchdog) {\r\n            throw new Error(`Item with the given id was not registered: ${itemId}.`);\r\n        }\r\n        return watchdog;\r\n    }\r\n    /**\r\n     * Checks whether an error comes from the context instance and not from the item instances.\r\n     *\r\n     * @internal\r\n     */\r\n    _isErrorComingFromThisItem(error) {\r\n        for (const watchdog of this._watchdogs.values()) {\r\n            if (watchdog._isErrorComingFromThisItem(error)) {\r\n                return false;\r\n            }\r\n        }\r\n        return areConnectedThroughProperties(this._context, error.context);\r\n    }\r\n}\r\n/**\r\n * Manager of action queues that allows queuing async functions.\r\n */\r\nclass ActionQueues {\r\n    constructor() {\r\n        this._onEmptyCallbacks = [];\r\n        this._queues = new Map();\r\n        this._activeActions = 0;\r\n    }\r\n    /**\r\n     * Used to register callbacks that will be run when the queue becomes empty.\r\n     *\r\n     * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\r\n     */\r\n    onEmpty(onEmptyCallback) {\r\n        this._onEmptyCallbacks.push(onEmptyCallback);\r\n    }\r\n    /**\r\n     * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\r\n     *\r\n     * @param queueId The action queue ID.\r\n     * @param action A function that should be enqueued.\r\n     */\r\n    enqueue(queueId, action) {\r\n        const isMainAction = queueId === mainQueueId;\r\n        this._activeActions++;\r\n        if (!this._queues.get(queueId)) {\r\n            this._queues.set(queueId, Promise.resolve());\r\n        }\r\n        // List all sources of actions that the current action needs to await for.\r\n        // For the main action wait for all other actions.\r\n        // For the item action wait only for the item queue and the main queue.\r\n        const awaitedActions = isMainAction ?\r\n            Promise.all(this._queues.values()) :\r\n            Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\r\n        const queueWithAction = awaitedActions.then(action);\r\n        // Catch all errors in the main queue to stack promises even if an error occurred in the past.\r\n        const nonErrorQueue = queueWithAction.catch(() => { });\r\n        this._queues.set(queueId, nonErrorQueue);\r\n        return queueWithAction.finally(() => {\r\n            this._activeActions--;\r\n            if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\r\n                this._onEmptyCallbacks.forEach(cb => cb());\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\r\n *\r\n * @param elementOrArray The value to transform to an array.\r\n * @returns An array created from data.\r\n */\r\nfunction toArray(elementOrArray) {\r\n    return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\r\n}\r\n"]},"metadata":{},"sourceType":"module"}